/*2353126 信03 崔露文*/

/* 函数实现部分，{ }内的东西可以任意调整，目前的return 0只是一个示例，可改变 */

/* 不允许定义任何形式的外部全局、静态全局、宏定义、只读变量 */


/***************************************************************************
  函数名称：tj_tolower
  功    能：转小写
  说    明：自定义函数
***************************************************************************/
int tj_tolower(int x)
{
    if (x >= 'A' && x <= 'Z') {
        return x + 32;
    }
    return x;
}


/***************************************************************************
  函数名称：tj_toupper
  功    能：转大写
  说    明：自定义函数
***************************************************************************/
int tj_toupper(int x)
{
    if (x >= 'a' && x <= 'z') {
        return x - 32;
    }
    return x;
}

/***************************************************************************
  第一个
  函数名称：tj_strlen
  功    能：求字符串str的长度
  输入参数：
  返 回 值：字符串长度
  说    明：
***************************************************************************/
int tj_strlen(const char str[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int length = 0;
    while (str[length] != '\0')
    {
        length++;
    }
    return length; //return值可根据需要修改
}

/***************************************************************************
  第二个
  函数名称：tj_strcat
  功    能：将字符串s2追加到s1后面，含\0
  输入参数：
  返 回 值：0
  说    明：
***************************************************************************/
int tj_strcat(char s1[], const char s2[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int _s1 = 0;
    int _s2 = 0;
    //定位到s1数组的\0位置
    while (s1[_s1] != '\0') {
        _s1++;
    }
    //再把s2加到s1后面
    while (s2[_s2] != '\0') {
        s1[_s1] = s2[_s2];
        _s1++;
        _s2++;
    }
    s1[_s1] = '\0';
    //刚刚将s2加到s1后面时没有包含结尾的尾0，这里切记要补上！

    return 0; //return值可根据需要修改
}

/***************************************************************************
  第三个
  函数名称：tj_strncat
  功    能：将字符串s2的前len个字符追加到s1后面，并添加\0
  输入参数：
  返 回 值：0
  说    明：若len比s2的长度大，则追加整个s2即可（含\0）
***************************************************************************/
int tj_strncat(char s1[], const char s2[], const int len)
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int _s1 = 0;
    int _s2 = 0;
    //定位到s1数组的\0位置
    while (s1[_s1] != '\0') {
        _s1++;
    }
    //再把s2加到s1后面
    while (_s2 < len && s2[_s2] != '\0') {
        s1[_s1] = s2[_s2];
        _s1++;
        _s2++;
    }
    s1[_s1] = '\0';
    //刚刚将s2加到s1后面时没有包含结尾的尾0，这里切记要补上！

    return 0; //return值可根据需要修改
}

/***************************************************************************
  第四个
  函数名称：tj_strcpy
  功    能：将字符串s2复制到s1中，覆盖s1中原内容，复制时包含\0
  输入参数：
  返 回 值：0
  说    明：
***************************************************************************/
int tj_strcpy(char s1[], const char s2[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    
    //只需要一个变量即可完成，不再定义_s1和_s2
    int i = 0;
    while (s2[i] != '\0') 
    {
        s1[i] = s2[i];
        i++;
    }
    // 在s1的末尾添加终止字符'\0'
    s1[i] = '\0';
    return 0; //return值可根据需要修改
}

/***************************************************************************
  第五个
  函数名称：tj_strncpy
  功    能：将字符串s2的前len个字符复制到s1中，复制时不含\0
  输入参数：
  返 回 值：0
  说    明：若len比s2长度大，复制s2长度个字符即可（不含\0）
***************************************************************************/
int tj_strncpy(char s1[], const char s2[], const int len)
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */    
    int i = 0;
    while (i < len && s2[i] != '\0') 
    {
        s1[i] = s2[i];
        i++;
    }
    return 0; //return值可根据需要修改
}

/***************************************************************************
  第六个
  函数名称：tj_strcmp
  功    能：比较字符串s1和s2的大小，英文字母要区分大小写
  输入参数：
  返 回 值：相等为0，不等则为第一个不相等字符的ASCII差值
  说    明：
***************************************************************************/
int tj_strcmp(const char s1[], const char s2[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int i = 0;
    while (s1[i] != '\0' && s2[i] != '\0')
    {
        if (s1[i] != s2[i])
        {
            //找到不相等的字符，返回ASCII差值
            return s1[i] - s2[i];
        }
        i++;
    }
    //前面都相等但长度不等，如hello和helloo
    return s1[i] - s2[i];
}



/***************************************************************************
  第七个
  函数名称：tj_strcasecmp
  功    能：比较字符串s1和s2的大小，英文字母不区分大小写
  输入参数：
  返 回 值：相等为0，不等则为第一个不相等字符的ASCII差值
  说    明：若不相等处字符是不同的大小写字母，则统一转换为小写后比较；若不相等处是大写字母和其他字符，则返回对应小写字母和其他字符的ASCII差值
***************************************************************************/
int tj_strcasecmp(const char s1[], const char s2[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */    
    int i = 0;
    while (s1[i] != '\0' && s2[i] != '\0') 
    {
        if (tj_tolower(s1[i]) != tj_tolower(s2[i]))
        {
            //找到不相等的字符，返回ASCII差值
            return tj_tolower(s1[i]) - tj_tolower(s2[i]);
        }
        i++;    
    }
    //前面都相等但长度不等
    return tj_tolower(s1[i]) - tj_tolower(s2[i]);
}

/***************************************************************************
  第八个
  函数名称：tj_strncmp
  功    能：比较字符串s1和s2的前len个字符的大小，英文字母要区分大小写
  输入参数：
  返 回 值：相等为0，不等则为第一个不相等字符的ASCII差值
  说    明：若len大于s1或s2中字符串长度，则比较到短串的\0即结束
***************************************************************************/
int tj_strncmp(const char s1[], const char s2[], const int len)
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int i = 0;
    while (i < len && s1[i] != '\0' && s2[i] != '\0') 
    {
        if (s1[i] != s2[i]) 
        {
            return s1[i] - s2[i];
        }
        i++;
    }
    //循环结束了还没找到不同，说明s1、s2有一个已经结束。所以在循环外单列出来
    if (i < len) 
    {
        return s1[i] - s2[i];
    }
    return 0; //return值可根据需要修改
}

/***************************************************************************
  第九个
  函数名称：tj_strcasencmp
  功    能：比较字符串s1和s2的前len个字符的大小，英文字母不区分大小写
  输入参数：
  返 回 值：相等为0，不等则为第一个不相等字符的ASCII差值
  说    明：
***************************************************************************/
int tj_strcasencmp(const char s1[], const char s2[], const int len)
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int i = 0;
    while (i < len && s1[i] != '\0' && s2[i] != '\0')
    {
        if (tj_tolower(s1[i]) != tj_tolower(s2[i]))
        {
            return tj_tolower(s1[i]) - tj_tolower(s2[i]);
        }
        i++;
    }
    //循环结束了还没找到不同，说明s1、s2有一个已经结束。所以在循环外单列出来
    if (i < len)
    {
        int x1 = s1[i] ? tj_tolower(s1[i]) : 0;
        int x2 = s2[i] ? tj_tolower(s2[i]) : 0;
        return x1 - x2;
    }
    return 0; //return值可根据需要修改
}

/***************************************************************************
  第十个
  函数名称：tj_strupr
  功    能：将字符串str中所有小写字母均转为大写，其他字符不变，转换后放在原串中
  输入参数：
  返 回 值：0
  说    明：
***************************************************************************/
int tj_strupr(char str[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int i = 0;
    while (str[i] != '\0') {
        str[i] = tj_toupper(str[i]);
        i++;
    }
    return 0; //return值可根据需要修改
}

/***************************************************************************
  第十一个
  函数名称：tj_strlwr
  功    能：将字符串str中所有大写字母均转为小写，其他字符不变，转换后放在原串中
  输入参数：
  返 回 值：0
  说    明：
***************************************************************************/
int tj_strlwr(char str[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int i = 0;
    while (str[i] != '\0') {
        str[i] = tj_tolower(str[i]);
        i++;
    }
    return 0; //return值可根据需要修改
}

/***************************************************************************
  第十二个
  函数名称：tj_strchr
  功    能：在字符串str中寻找字符ch第一次出现的位置，顺序是从左到右
  输入参数：
  返 回 值：若找到，则返回1~n（位置从1开始），未找到则返回0
  说    明：
***************************************************************************/
int tj_strchr(const char str[], char ch)
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int position = 0;
    while (str[position] != '\0') 
    { 
        if (str[position] == ch) 
        {
            return position + 1; //别忘了加1！数组是从0开始的，但计数是从1开始的
        }
        position++;
    }
    return 0; //如果未找到字符，则返回0
}

/***************************************************************************
  第十三个
  函数名称：tj_strstr
  功    能：在字符串str中寻找字符串substr第一次出现的位置，顺序是从左到右
  输入参数：
  返 回 值：若找到，则返回1~n（位置从1开始），未找到则返回0
  说    明：
***************************************************************************/
int tj_strstr(const char str[], const char substr[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int i, j;
    for (i = 0; str[i] != '\0'; i++) 
    {
        //在str中找到substr的第一个字符时，开始比较
        if (str[i] == substr[0]) {
            //一直比较到和substr对不上了或substr结束了
            for (j = 1; substr[j] != '\0' && str[i + j] == substr[j];j++) 
            {
                //要干的事在条件部分都干完了
            }
            if (substr[j] == '\0') 
            {
                return i + 1; //别忘了+1
            }
        }
    }
    return 0; //如果未找到字符串，则返回0
}

/***************************************************************************
  第十四个
  函数名称：tj_strrchr
  功    能：在字符串str中寻找字符ch第一次出现的位置，顺序是从右到左
  输入参数：
  返 回 值：若找到，则返回1~n（位置从1开始），未找到则返回0
  说    明：
***************************************************************************/
int tj_strrchr(const char str[], const char ch)
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int position = -666;
    int i = 0;
    //先把i大小定位到末尾
    while (str[i] != '\0') 
    {
        i++;
    }
    while (i >= 0) 
    {
        if (str[i] == ch) {
            position = i;
            break; //找到就退出循环
        }
        i--;
    }
    if (position == -666)
    {
        return 0;//遍历了一圈position还没变，表示没找到，返回0
    }
    else
        return position + 1;//别忘了+1！
}

/***************************************************************************
  第十五个
  函数名称：tj_strrstr
  功    能：在字符串str中寻找字符串substr第一次出现的位置，顺序是从右到左
  输入参数：
  返 回 值：若找到，则返回1~n（位置从1开始），未找到则返回0
  说    明：
***************************************************************************/
int tj_strrstr(const char str[], const char substr[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    //先算出两个串长度
    int length1 = 0, length2 = 0;
    while (str[length1] != '\0')
    {
        length1++;
    }
    while (substr[length2] != '\0')
    {
        length2++;
    }
    for (int i = length1 - length2; i >= 0; i--) //当str剩下的长度小于substr长度了，就肯定不能找到相同部分了
    {
        //从碰到和substr第一个字符相等开始j做++，只要一直对得上，j就一直++，直到等于substr串的长度
        int j = 0;
        for (j = 0; j < length1; j++) 
        {
            if (str[i + j] != substr[j]) 
            {
                break; //如果有字符不匹配，跳出循环，j不再++
            }
        }
        
        if (j == length2) //j加到和substr一样长了，说明一直都对得上，即找到了str中substr的部分
        {
            return i + 1; //别忘了+1
        }
    }
    return 0; //如果未找到字符串，则返回0
}

/***************************************************************************
  第十六个
  函数名称：tj_strrev
  功    能：字符串反转，放入原串中
  输入参数：
  返 回 值：0
  说    明：
***************************************************************************/
int tj_strrev(char str[])
{
    /* 注意：函数内不允许定义任何形式的数组（包括静态数组） */
    int length = 0;
    //先得到str串的长度
    while (str[length] != '\0')
    {
        length++;
    }
    //注意：因为是数组，所以这里的i是0不是1，j是length-1
    //一直循环到i和j相邻了或者重合了
    for (int i = 0, j = length - 1; i < j; i++, j--) 
    {
        char linshi = str[i];
        str[i] = str[j];
        str[j] = linshi;
    }
    return 0; //return值可根据需要修改
}


/*已经做完了检查的时候才想起来第一个写的就是求字符串长度的函数，
但后面还在傻傻的一直用循环自己求，呜呜呜，因为已经写完了就没再修改*/